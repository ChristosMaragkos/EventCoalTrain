<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.github/workflows/release_nuget.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.github/workflows/release_nuget.yml" />
              <option name="originalContent" value="name: Release NuGet Package&#10;&#10;on:&#10;  push:&#10;    tags:&#10;      - 'v*'           # Triggers on tags like v1.0.0, v2.1.3 etc.&#10;  workflow_dispatch:&#10;    inputs:&#10;      dry_run:&#10;        description: 'Perform a dry run (build/test/pack only; do not publish)'&#10;        required: false&#10;        type: boolean&#10;        default: true&#10;&#10;jobs:&#10;  build-pack-publish:&#10;    runs-on: ubuntu-latest&#10;&#10;    steps:&#10;      - name: Checkout code&#10;        uses: actions/checkout@v4&#10;&#10;      - name: Setup .NET&#10;        uses: actions/setup-dotnet@v4&#10;        with:&#10;          dotnet-version: |&#10;            9.0.x&#10;            8.0.x&#10;&#10;      - name: Restore dependencies&#10;        run: dotnet restore EventCoalTrain.sln&#10;&#10;      - name: Build (Core only)&#10;        run: dotnet build Core/EventCoalTrain.csproj --configuration Release --no-restore&#10;&#10;      - name: Pack (Core only)&#10;        run: dotnet pack Core/EventCoalTrain.csproj --configuration Release --no-build --output ./nupkg&#10;&#10;      - name: Upload NuGet package artifact (always)&#10;        if: always()&#10;        uses: actions/upload-artifact@v4&#10;        with:&#10;          name: nupkg&#10;          path: ./nupkg/*.nupkg&#10;&#10;      - name: Publish to NuGet.org&#10;        if: ${{ github.event_name != 'workflow_dispatch' || (github.event_name == 'workflow_dispatch' &amp;&amp; inputs.dry_run == false) }}&#10;        run: dotnet nuget push ./nupkg/*.nupkg --api-key ${{ secrets.NUGET_API_KEY }} --source https://api.nuget.org/v3/index.json --skip-duplicate&#10;&#10;      - name: Upload NuGet package to GitHub Release&#10;        if: ${{ github.event_name != 'workflow_dispatch' || (github.event_name == 'workflow_dispatch' &amp;&amp; inputs.dry_run == false) }}&#10;        uses: softprops/action-gh-release@v2&#10;        with:&#10;          files: ./nupkg/*.nupkg&#10;        env:&#10;          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}&#10;&#10;      - name: Upload Test Results&#10;        if: always()&#10;        uses: actions/upload-artifact@v4&#10;        with:&#10;          name: test-results&#10;          path: '**/TestResults/*.trx'&#10;" />
              <option name="updatedContent" value="name: Release NuGet Package&#10;&#10;on:&#10;  push:&#10;    tags:&#10;      - 'v*'           # Triggers on tags like v1.0.0, v2.1.3 etc.&#10;  workflow_dispatch:&#10;    inputs:&#10;      dry_run:&#10;        description: 'Perform a dry run (build/test/pack only; do not publish)'&#10;        required: false&#10;        type: boolean&#10;        default: true&#10;&#10;jobs:&#10;  build-pack-publish:&#10;    runs-on: ubuntu-latest&#10;&#10;    steps:&#10;      - name: Checkout code&#10;        uses: actions/checkout@v4&#10;&#10;      - name: Setup .NET&#10;        uses: actions/setup-dotnet@v4&#10;        with:&#10;          dotnet-version: |&#10;            9.0.x&#10;            8.0.x&#10;&#10;      - name: Restore dependencies&#10;        run: dotnet restore EventCoalTrain.sln&#10;&#10;      - name: Build (Core only)&#10;        run: dotnet build Core/EventCoalTrain.csproj --configuration Release --no-restore&#10;&#10;      - name: Pack (Core only)&#10;        run: dotnet pack Core/EventCoalTrain.csproj --configuration Release --no-build --output ./nupkg&#10;&#10;      - name: Upload NuGet package artifact (always)&#10;        if: always()&#10;        uses: actions/upload-artifact@v4&#10;        with:&#10;          name: nupkg&#10;          path: ./nupkg/*.nupkg&#10;&#10;      - name: Publish to NuGet.org&#10;        if: ${{ github.event_name != 'workflow_dispatch' || (github.event_name == 'workflow_dispatch' &amp;&amp; inputs.dry_run == false) }}&#10;        run: dotnet nuget push ./nupkg/*.nupkg --api-key ${{ secrets.NUGET_API_KEY }} --source https://api.nuget.org/v3/index.json --skip-duplicate&#10;&#10;      - name: Upload NuGet package to GitHub Release&#10;        if: ${{ github.event_name != 'workflow_dispatch' || (github.event_name == 'workflow_dispatch' &amp;&amp; inputs.dry_run == false) }}&#10;        uses: softprops/action-gh-release@v2&#10;        with:&#10;          files: ./nupkg/*.nupkg&#10;        env:&#10;          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}&#10;&#10;      - name: Upload Test Results&#10;        if: always()&#10;        uses: actions/upload-artifact@v4&#10;        with:&#10;          name: test-results&#10;          path: '**/TestResults/*.trx'" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Core/EventCoalTrain.csproj">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/EventCoalTrain.csproj" />
              <option name="originalContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;&#10;    &lt;PropertyGroup&gt;&#10;        &lt;TargetFrameworks&gt;net8.0;netstandard2.1&lt;/TargetFrameworks&gt;&#10;        &lt;LangVersion&gt;latestMajor&lt;/LangVersion&gt;&#10;        &lt;GenerateDocumentationFile&gt;true&lt;/GenerateDocumentationFile&gt;&#10;        &lt;PackageId&gt;EventCoalTrain&lt;/PackageId&gt;&#10;        &lt;Version&gt;2.0.0&lt;/Version&gt;&#10;        &lt;Authors&gt;Christos Maragkos&lt;/Authors&gt;&#10;        &lt;Description&gt;Event system for Godot (.NET 8.0) and Unity (.NET Standard 2.1).&lt;/Description&gt;&#10;        &lt;RepositoryUrl&gt;https://github.com/ChristosMaragkos/EventCoalTrain&lt;/RepositoryUrl&gt;&#10;        &lt;PackageLicenseExpression&gt;MIT&lt;/PackageLicenseExpression&gt;&#10;        &lt;PackageProjectUrl&gt;https://github.com/ChristosMaragkos/EventCoalTrain&lt;/PackageProjectUrl&gt;&#10;        &lt;Copyright&gt;Copyright © 2025 Christos Maragkos&lt;/Copyright&gt;&#10;        &lt;IncludeSymbols&gt;true&lt;/IncludeSymbols&gt;&#10;        &lt;SymbolPackageFormat&gt;snupkg&lt;/SymbolPackageFormat&gt;&#10;        &lt;PackageReadmeFile&gt;README.md&lt;/PackageReadmeFile&gt;&#10;    &lt;/PropertyGroup&gt;&#10;&#10;    &lt;ItemGroup&gt;&#10;        &lt;!-- Ensure buildTransitive props are packed so consumers get the EVENTCOALTRAIN symbol --&gt;&#10;        &lt;None Include=&quot;buildTransitive\**\*.*&quot; Pack=&quot;true&quot; PackagePath=&quot;buildTransitive\&quot; /&gt;&#10;        &lt;!-- Include README in the package root --&gt;&#10;        &lt;None Include=&quot;README.md&quot; Pack=&quot;true&quot; PackagePath=&quot;/&quot; /&gt;&#10;    &lt;/ItemGroup&gt;&#10;&#10;&lt;/Project&gt;&#10;" />
              <option name="updatedContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;&#10;    &lt;PropertyGroup&gt;&#10;        &lt;TargetFrameworks&gt;net8.0;netstandard2.1&lt;/TargetFrameworks&gt;&#10;        &lt;LangVersion&gt;latestMajor&lt;/LangVersion&gt;&#10;        &lt;GenerateDocumentationFile&gt;true&lt;/GenerateDocumentationFile&gt;&#10;        &lt;PackageId&gt;EventCoalTrain&lt;/PackageId&gt;&#10;        &lt;Version&gt;2.0.0&lt;/Version&gt;&#10;        &lt;Authors&gt;Christos Maragkos&lt;/Authors&gt;&#10;        &lt;Description&gt;Event system for Godot (.NET 8.0) and Unity (.NET Standard 2.1).&lt;/Description&gt;&#10;        &lt;RepositoryUrl&gt;https://github.com/ChristosMaragkos/EventCoalTrain&lt;/RepositoryUrl&gt;&#10;        &lt;PackageLicenseExpression&gt;MIT&lt;/PackageLicenseExpression&gt;&#10;        &lt;PackageProjectUrl&gt;https://github.com/ChristosMaragkos/EventCoalTrain&lt;/PackageProjectUrl&gt;&#10;        &lt;Copyright&gt;Copyright © 2025 Christos Maragkos&lt;/Copyright&gt;&#10;        &lt;IncludeSymbols&gt;true&lt;/IncludeSymbols&gt;&#10;        &lt;SymbolPackageFormat&gt;snupkg&lt;/SymbolPackageFormat&gt;&#10;        &lt;PackageReadmeFile&gt;README.md&lt;/PackageReadmeFile&gt;&#10;    &lt;/PropertyGroup&gt;&#10;&#10;    &lt;ItemGroup&gt;&#10;        &lt;!-- Ensure buildTransitive props are packed so consumers get the EVENTCOALTRAIN symbol --&gt;&#10;        &lt;None Include=&quot;buildTransitive\**\*.*&quot; Pack=&quot;true&quot; PackagePath=&quot;buildTransitive\&quot; /&gt;&#10;        &lt;!-- Include README in the package root --&gt;&#10;        &lt;None Include=&quot;README.md&quot; Pack=&quot;true&quot; PackagePath=&quot;/&quot; /&gt;&#10;    &lt;/ItemGroup&gt;&#10;&#10;&lt;/Project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Core/EventHandling/EventBus.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/EventHandling/EventBus.cs" />
              <option name="originalContent" value="#nullable enable&#10;using System;&#10;using System.Collections.Generic;&#10;using EventCoalTrain.EventSource;&#10;using EventCoalTrain.EventStructure;&#10;&#10;namespace EventCoalTrain.EventHandling;&#10;/// &lt;summary&gt;&#10;/// Static wrapper over a thread-safe event bus implementation.&#10;/// &lt;/summary&gt;&#10;public static class EventBus&#10;{&#10;    private static IEventBus _bus = new DefaultEventBus();&#10;&#10;    /// &lt;summary&gt;&#10;    /// Contains all registered event key names (used by EventKey.Of for uniqueness).&#10;    /// &lt;/summary&gt;&#10;    public static readonly HashSet&lt;string&gt; RegisteredKeys = new();&#10;&#10;    /// &lt;summary&gt;&#10;    /// Access the underlying event bus instance (supports IDisposable subscriptions).&#10;    /// &lt;/summary&gt;&#10;    public static IEventBus Instance =&gt; _bus;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Replace the underlying bus implementation.&#10;    /// &lt;/summary&gt;&#10;    public static void Configure(IEventBus bus)&#10;        =&gt; _bus = bus ?? throw new ArgumentNullException(nameof(bus));&#10;&#10;    /// &lt;summary&gt;&#10;    /// Raised when a subscriber throws during publish.&#10;    /// &lt;/summary&gt;&#10;    public static event Action&lt;Exception, IEventKey, Delegate&gt;? OnPublishError&#10;    {&#10;        add =&gt; _bus.OnPublishError += value;&#10;        remove =&gt; _bus.OnPublishError -= value;&#10;    }&#10;&#10;    // Subscribe (legacy shape using Packet/Notification)&#10;    public static void Subscribe&lt;TPayload&gt;(Packet&lt;TPayload&gt; packet, Action&lt;TPayload&gt; handler)&#10;        =&gt; _bus.Subscribe(packet.Key, handler);&#10;&#10;    public static void Subscribe(Notification notification, Action handler)&#10;        =&gt; _bus.Subscribe(notification, handler);&#10;&#10;    // Unsubscribe (legacy shape)&#10;    public static void Unsubscribe&lt;TPayload&gt;(Packet&lt;TPayload&gt; packet, Action&lt;TPayload&gt; handler)&#10;        =&gt; _bus.Unsubscribe(packet.Key, handler);&#10;&#10;    public static void Unsubscribe(Notification notification, Action handler)&#10;        =&gt; _bus.Unsubscribe(notification, handler);&#10;&#10;    // Publish&#10;    public static void Publish&lt;TPayload&gt;(Packet&lt;TPayload&gt; packet) =&gt; _bus.Publish(packet);&#10;    public static void Publish(Notification notification) =&gt; _bus.Publish(notification);&#10;&#10;    /// &lt;summary&gt;&#10;    /// Publish using a cached packet descriptor (constructed with key only) and a fresh payload instance.&#10;    /// &lt;/summary&gt;&#10;    public static void Publish&lt;TPayload&gt;(Packet&lt;TPayload&gt; packetDescriptor, TPayload payload)&#10;        =&gt; _bus.Publish(new Packet&lt;TPayload&gt;(packetDescriptor.Key, payload));&#10;&#10;    /// &lt;summary&gt;&#10;    /// Convenience publish overload directly from a cached key and a payload instance.&#10;    /// &lt;/summary&gt;&#10;    public static void Publish&lt;TPayload&gt;(EventKey&lt;TPayload&gt; key, TPayload payload)&#10;        =&gt; _bus.Publish(new Packet&lt;TPayload&gt;(key, payload));&#10;&#10;    // Bulk operations&#10;    public static void UnsubscribeAll(IEventKey key) =&gt; _bus.UnsubscribeAll(key);&#10;    public static bool HasSubscribers(IEventKey key) =&gt; _bus.HasSubscribers(key);&#10;    public static int Count(IEventKey key) =&gt; _bus.Count(key);&#10;    public static void Clear() =&gt; _bus.Clear();&#10;}" />
              <option name="updatedContent" value="#nullable enable&#13;&#10;using System;&#13;&#10;using System.Collections.Generic;&#13;&#10;using EventCoalTrain.EventSource;&#13;&#10;using EventCoalTrain.EventStructure;&#13;&#10;&#13;&#10;namespace EventCoalTrain.EventHandling;&#13;&#10;/// &lt;summary&gt;&#13;&#10;/// Static wrapper over a thread-safe event bus implementation.&#13;&#10;/// &lt;/summary&gt;&#13;&#10;public static class EventBus&#13;&#10;{&#13;&#10;    private static IEventBus _bus = new DefaultEventBus();&#13;&#10;&#13;&#10;    /// &lt;summary&gt;&#13;&#10;    /// Contains all registered event key names (used by EventKey.Of for uniqueness).&#13;&#10;    /// &lt;/summary&gt;&#13;&#10;    public static readonly HashSet&lt;string&gt; RegisteredKeys = new();&#13;&#10;&#13;&#10;    /// &lt;summary&gt;&#13;&#10;    /// Access the underlying event bus instance (supports IDisposable subscriptions).&#13;&#10;    /// &lt;/summary&gt;&#13;&#10;    public static IEventBus Instance =&gt; _bus;&#13;&#10;&#13;&#10;    /// &lt;summary&gt;&#13;&#10;    /// Replace the underlying bus implementation.&#13;&#10;    /// &lt;/summary&gt;&#13;&#10;    public static void Configure(IEventBus bus)&#13;&#10;        =&gt; _bus = bus ?? throw new ArgumentNullException(nameof(bus));&#13;&#10;&#13;&#10;    /// &lt;summary&gt;&#13;&#10;    /// Raised when a subscriber throws during publish.&#13;&#10;    /// &lt;/summary&gt;&#13;&#10;    public static event Action&lt;Exception, IEventKey, Delegate&gt;? OnPublishError&#13;&#10;    {&#13;&#10;        add =&gt; _bus.OnPublishError += value;&#13;&#10;        remove =&gt; _bus.OnPublishError -= value;&#13;&#10;    }&#13;&#10;&#13;&#10;    // Subscribe (legacy shape using Packet/Notification)&#13;&#10;    public static void Subscribe&lt;TPayload&gt;(Packet&lt;TPayload&gt; packet, Action&lt;TPayload&gt; handler)&#13;&#10;        =&gt; _bus.Subscribe(packet.Key, handler);&#13;&#10;&#13;&#10;    public static void Subscribe(Notification notification, Action handler)&#13;&#10;        =&gt; _bus.Subscribe(notification, handler);&#13;&#10;&#13;&#10;    // Unsubscribe (legacy shape)&#13;&#10;    public static void Unsubscribe&lt;TPayload&gt;(Packet&lt;TPayload&gt; packet, Action&lt;TPayload&gt; handler)&#13;&#10;        =&gt; _bus.Unsubscribe(packet.Key, handler);&#13;&#10;&#13;&#10;    public static void Unsubscribe(Notification notification, Action handler)&#13;&#10;        =&gt; _bus.Unsubscribe(notification, handler);&#13;&#10;&#13;&#10;    // Publish&#13;&#10;    public static void Publish&lt;TPayload&gt;(Packet&lt;TPayload&gt; packet) =&gt; _bus.Publish(packet);&#13;&#10;    public static void Publish(Notification notification) =&gt; _bus.Publish(notification);&#13;&#10;&#13;&#10;    /// &lt;summary&gt;&#13;&#10;    /// Publish using a cached packet descriptor (constructed with key only) and a fresh payload instance.&#13;&#10;    /// &lt;/summary&gt;&#13;&#10;    public static void Publish&lt;TPayload&gt;(Packet&lt;TPayload&gt; packetDescriptor, TPayload payload)&#13;&#10;        =&gt; _bus.Publish(new Packet&lt;TPayload&gt;(packetDescriptor.Key, payload));&#13;&#10;&#13;&#10;    /// &lt;summary&gt;&#13;&#10;    /// Convenience publish overload directly from a cached key and a payload instance.&#13;&#10;    /// &lt;/summary&gt;&#13;&#10;    public static void Publish&lt;TPayload&gt;(EventKey&lt;TPayload&gt; key, TPayload payload)&#13;&#10;        =&gt; _bus.Publish(new Packet&lt;TPayload&gt;(key, payload));&#13;&#10;&#13;&#10;    // Bulk operations&#13;&#10;    public static void UnsubscribeAll(IEventKey key) =&gt; _bus.UnsubscribeAll(key);&#13;&#10;    public static bool HasSubscribers(IEventKey key) =&gt; _bus.HasSubscribers(key);&#13;&#10;    public static int Count(IEventKey key) =&gt; _bus.Count(key);&#13;&#10;    public static void Clear() =&gt; _bus.Clear();&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Core/EventSource/Packet.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/EventSource/Packet.cs" />
              <option name="originalContent" value="using EventCoalTrain.EventStructure;&#10;&#10;namespace EventCoalTrain.EventSource;&#10;&#10;/// &lt;summary&gt;&#10;/// Represents a packet containing an event key and its associated payload.&#10;/// Packets are used to notify subscribers about events while transferring data.&#10;/// They can be used to send data between different parts of the application,&#10;/// like a player scoring points with the payload being the score increase.&#10;/// &lt;/summary&gt;&#10;/// &lt;typeparam name=&quot;TPayload&quot;&gt;The type of the payload.&lt;/typeparam&gt;&#10;public class Packet&lt;TPayload&gt; : IEvent&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Gets the event key associated with this packet.&#10;    /// &lt;/summary&gt;&#10;    public EventKey&lt;TPayload&gt; Key { get; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the payload carried by this packet.&#10;    /// &lt;/summary&gt;&#10;    public TPayload Payload { get; }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Gets the name of the event from the key.&#10;    /// &lt;/summary&gt;&#10;    public string Name =&gt; Key.Name;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Initializes a new descriptor-like instance of the &lt;see cref=&quot;Packet{TPayload}&quot;/&gt; class that only carries the key.&#10;    /// Use &lt;c&gt;EventBus.Publish(packet, payload)&lt;/c&gt; to publish with a fresh payload per call.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;key&quot;&gt;The event key.&lt;/param&gt;&#10;    public Packet(EventKey&lt;TPayload&gt; key)&#10;    {&#10;        Key = key;&#10;        // Payload intentionally left at default; use Publish(packet, payload) overload for sending data.&#10;        // This enables safely caching packets as descriptors.&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Initializes a new instance of the &lt;see cref=&quot;Packet{TPayload}&quot;/&gt; class.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;key&quot;&gt;The event key.&lt;/param&gt;&#10;    /// &lt;param name=&quot;payload&quot;&gt;The payload to associate with the key.&lt;/param&gt;&#10;    public Packet(EventKey&lt;TPayload&gt; key, TPayload payload)&#10;    {&#10;        Key = key;&#10;        Payload = payload;&#10;    }&#10;}" />
              <option name="updatedContent" value="using EventCoalTrain.EventStructure;&#10;&#10;namespace EventCoalTrain.EventSource;&#10;&#10;/// &lt;summary&gt;&#10;/// Represents a packet containing an event key and its associated payload.&#10;/// Packets are used to notify subscribers about events while transferring data.&#10;/// They can be used to send data between different parts of the application,&#10;/// like a player scoring points with the payload being the score increase.&#10;/// &lt;/summary&gt;&#10;/// &lt;typeparam name=&quot;TPayload&quot;&gt;The type of the payload.&lt;/typeparam&gt;&#10;public class Packet&lt;TPayload&gt; : IEvent&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Gets the event key associated with this packet.&#10;    /// &lt;/summary&gt;&#10;    public EventKey&lt;TPayload&gt; Key { get; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the payload carried by this packet.&#10;    /// &lt;/summary&gt;&#10;    public TPayload Payload { get; }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Gets the name of the event from the key.&#10;    /// &lt;/summary&gt;&#10;    public string Name =&gt; Key.Name;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Initializes a new descriptor-like instance of the &lt;see cref=&quot;Packet{TPayload}&quot;/&gt; class that only carries the key.&#10;    /// Use &lt;c&gt;EventBus.Publish(packet, payload)&lt;/c&gt; to publish with a fresh payload per call.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;key&quot;&gt;The event key.&lt;/param&gt;&#10;    public Packet(EventKey&lt;TPayload&gt; key)&#10;    {&#10;        Key = key;&#10;        // Payload intentionally left at default; use Publish(packet, payload) overload for sending data.&#10;        // This enables safely caching packets as descriptors.&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Initializes a new instance of the &lt;see cref=&quot;Packet{TPayload}&quot;/&gt; class.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;key&quot;&gt;The event key.&lt;/param&gt;&#10;    /// &lt;param name=&quot;payload&quot;&gt;The payload to associate with the key.&lt;/param&gt;&#10;    public Packet(EventKey&lt;TPayload&gt; key, TPayload payload)&#10;    {&#10;        Key = key;&#10;        Payload = payload;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Core/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/README.md" />
              <option name="originalContent" value="# EventCoalTrain&#10;&#10;Simple, typed event bus for .NET (Unity, Godot, and general C# apps).&#10;&#10;Supported TFMs: netstandard2.1, net8.0.&#10;&#10;## Features&#10;- Strongly-typed event keys (EventKey&lt;T&gt;)&#10;- Packets with payloads and Notifications without payloads&#10;- Thread-safe subscriptions and publishing&#10;- Snapshot iteration during publish (handlers can add/remove safely)&#10;- Empty-list cleanup to avoid leaks&#10;- Optional error callback for subscriber exceptions&#10;- Static EventBus wrapper and an IEventBus interface with IDisposable subscriptions&#10;- Global preprocessor symbol for consumers: EVENTCOALTRAIN&#10;&#10;## Best practice: define record payloads and cache keys and packet descriptors&#10;Model your domain events with record (or record struct) payloads for clarity and immutability, then create a typed EventKey based on that record. Cache and reuse:&#10;- the EventKey&lt;TPayload&gt;&#10;- an optional Packet&lt;TPayload&gt; descriptor constructed with the key only (no payload)&#10;- Notification instances for no-payload events&#10;&#10;Warning:&#10;- Don’t allocate Notification or Packet&lt;T&gt; inline at Publish/Subscribe call sites (e.g., `new Notification(...)` or `new Packet&lt;T&gt;(key, payload)` in the argument list). Instead, cache the Notification or a Packet&lt;T&gt; descriptor (key-only) and publish with a fresh payload per call via `Publish(descriptor, payload)` or `Publish(key, payload)`.&#10;- This avoids unnecessary allocations, keeps event identity stable, and prevents stale state.&#10;&#10;```csharp&#10;using EventCoalTrain.EventStructure;&#10;using EventCoalTrain.EventSource;&#10;&#10;// 1) Define the payload as a record/record struct&#10;public readonly record struct ScoreIncreased(int Amount, string Source);&#10;&#10;public static class Events&#10;{&#10;    // 2) Define and cache the event key typed on the payload record&#10;    public static readonly EventKey&lt;ScoreIncreased&gt; ScoreIncreasedKey = EventKey&lt;ScoreIncreased&gt;.Of(&quot;ScoreIncreased&quot;);&#10;&#10;    // 3) Optionally cache a packet descriptor (key only)&#10;    public static readonly Packet&lt;ScoreIncreased&gt; ScoreIncreased = new Packet&lt;ScoreIncreased&gt;(ScoreIncreasedKey);&#10;&#10;    // Notification-style event (no payload). Cache both key and notification instance.&#10;    public static readonly EventKey&lt;Unit&gt; ButtonClickedKey = EventKey&lt;Unit&gt;.Of(&quot;ButtonClicked&quot;);&#10;    public static readonly Notification ButtonClicked = new Notification(ButtonClickedKey);&#10;}&#10;```&#10;&#10;- Subscribe using the cached keys/notifications via EventBus.Instance.&#10;- Publish using either the cached packet descriptor or the key directly with a fresh payload instance each time.&#10;&#10;## Quick start&#10;```csharp&#10;using EventCoalTrain.EventStructure;&#10;using EventCoalTrain.EventSource;&#10;using EventCoalTrain.EventHandling;&#10;&#10;// Subscribe (preferred instance API returning IDisposable)&#10;var subScore = EventBus.Instance.Subscribe(Events.ScoreIncreasedKey, e =&gt; Console.WriteLine($&quot;+{e.Amount} ({e.Source})&quot;));&#10;var subClick = EventBus.Instance.Subscribe(Events.ButtonClicked, () =&gt; Console.WriteLine(&quot;clicked&quot;));&#10;&#10;// Publish with a cached packet descriptor + fresh payload&#10;EventBus.Publish(Events.ScoreIncreased, new ScoreIncreased(10, &quot;LevelComplete&quot;));&#10;&#10;// Or publish with key + payload&#10;EventBus.Publish(Events.ScoreIncreasedKey, new ScoreIncreased(5, &quot;Combo&quot;));&#10;&#10;// Notification publish reuses cached notification&#10;EventBus.Publish(Events.ButtonClicked);&#10;&#10;// Unsubscribe via disposables&#10;subScore.Dispose();&#10;subClick.Dispose();&#10;```&#10;&#10;Notes:&#10;- Cache and reuse EventKey&lt;T&gt; and optional Packet&lt;T&gt; descriptors; supply a new payload per publish. This is allocation-light (especially with record structs) and thread-safe.&#10;- Prefer EventBus.Instance for subscriptions to get IDisposable handles.&#10;- The static wrapper methods exist for convenience/back-compat; the instance API is recommended for lifecycle management.&#10;&#10;## API overview&#10;&#10;### Event keys, packet descriptors, and payload records&#10;```csharp&#10;public readonly record struct DamageTaken(int Amount, string Cause);&#10;&#10;var DamageTakenKey = EventKey&lt;DamageTaken&gt;.Of(&quot;DamageTaken&quot;);&#10;var DamageTakenPacket = new Packet&lt;DamageTaken&gt;(DamageTakenKey); // descriptor&#10;var TickedKey = EventKey&lt;Unit&gt;.Of(&quot;Ticked&quot;);&#10;var Ticked = new Notification(TickedKey);&#10;```&#10;- Equality and GetHashCode of EventKey include both Name and payload type to avoid cross-type collisions.&#10;- Names must still be unique globally (across all payload types).&#10;&#10;### Subscribing (instance, preferred)&#10;```csharp&#10;var sub1 = EventBus.Instance.Subscribe(DamageTakenKey, d =&gt; Console.WriteLine($&quot;damage {d.Amount} from {d.Cause}&quot;));&#10;var sub2 = EventBus.Instance.Subscribe(Ticked, () =&gt; Console.WriteLine(&quot;ticked&quot;));&#10;&#10;// Unsubscribe&#10;sub1.Dispose();&#10;sub2.Dispose();&#10;```&#10;&#10;### Publishing&#10;```csharp&#10;// Using cached descriptor + fresh payload&#10;EventBus.Publish(DamageTakenPacket, new DamageTaken(5, &quot;Trap&quot;));&#10;&#10;// Or using key + payload&#10;EventBus.Publish(DamageTakenKey, new DamageTaken(3, &quot;Fall&quot;));&#10;&#10;EventBus.Publish(Ticked);&#10;```&#10;&#10;### Bulk operations&#10;```csharp&#10;EventBus.UnsubscribeAll(DamageTakenKey);&#10;bool any = EventBus.HasSubscribers(DamageTakenKey);&#10;int count = EventBus.Count(DamageTakenKey);&#10;EventBus.Clear(); // remove all subscriptions&#10;```&#10;&#10;### Error handling&#10;When a subscriber throws during publish, publishing continues for other subscribers. You can observe errors via a callback:&#10;```csharp&#10;EventBus.OnPublishError += (ex, key, del) =&gt;&#10;{&#10;    Console.Error.WriteLine($&quot;Subscriber threw for {key.Name}: {ex}&quot;);&#10;};&#10;```&#10;&#10;## Thread-safety and iteration&#10;- The internal subscribers map is guarded by a lock for all mutations and lookups.&#10;- Publish iterates over a snapshot to avoid issues if handlers subscribe/unsubscribe during delivery.&#10;- After unsubscription, empty handler lists are removed to keep memory usage small.&#10;&#10;## NuGet preprocessor symbol&#10;When you add the EventCoalTrain NuGet package, the compile symbol `EVENTCOALTRAIN` is automatically defined in your consuming project via a `buildTransitive` MSBuild props.&#10;&#10;Example:&#10;```csharp&#10;#if EVENTCOALTRAIN&#10;Console.WriteLine(&quot;EventCoalTrain is referenced.&quot;);&#10;#endif&#10;```&#10;Works for direct and transitive references. No project changes required.&#10;&#10;### Unity without NuGet&#10;If you drop the DLL directly into Unity (not via NuGet), Unity won’t import MSBuild props. Define the symbol manually in Player Settings &gt; Scripting Define Symbols: `EVENTCOALTRAIN`.&#10;&#10;### Opting out&#10;Override `DefineConstants` in your project, or add a props after package imports to remove the symbol if needed.&#10;&#10;### What’s inside the package&#10;The package ships `buildTransitive/EventCoalTrain.props` with:&#10;```xml&#10;&lt;Project&gt;&#10;  &lt;PropertyGroup&gt;&#10;    &lt;DefineConstants&gt;$(DefineConstants);EVENTCOALTRAIN&lt;/DefineConstants&gt;&#10;  &lt;/PropertyGroup&gt;&#10;&lt;/Project&gt;&#10;```&#10;&#10;## License&#10;MIT&#10;" />
              <option name="updatedContent" value="# EventCoalTrain&#10;&#10;Simple, typed event bus for .NET (Unity, Godot, and general C# apps).&#10;&#10;Supported TFMs: netstandard2.1, net8.0.&#10;&#10;## Features&#10;- Strongly-typed event keys (EventKey&lt;T&gt;)&#10;- Packets with payloads and Notifications without payloads&#10;- Thread-safe subscriptions and publishing&#10;- Snapshot iteration during publish (handlers can add/remove safely)&#10;- Empty-list cleanup to avoid leaks&#10;- Optional error callback for subscriber exceptions&#10;- Static EventBus wrapper and an IEventBus interface with IDisposable subscriptions&#10;- Global preprocessor symbol for consumers: EVENTCOALTRAIN&#10;&#10;## Best practice: define record payloads and cache keys and packet descriptors&#10;Model your domain events with record (or record struct) payloads for clarity and immutability, then create a typed EventKey based on that record. Cache and reuse:&#10;- the EventKey&lt;TPayload&gt;&#10;- an optional Packet&lt;TPayload&gt; descriptor constructed with the key only (no payload)&#10;- Notification instances for no-payload events&#10;&#10;Warning:&#10;- Don’t allocate Notification or Packet&lt;T&gt; inline at Publish/Subscribe call sites (e.g., `new Notification(...)` or `new Packet&lt;T&gt;(key, payload)` in the argument list). Instead, cache the Notification or a Packet&lt;T&gt; descriptor (key-only) and publish with a fresh payload per call via `Publish(descriptor, payload)` or `Publish(key, payload)`.&#10;- This avoids unnecessary allocations, keeps event identity stable, and prevents stale state.&#10;&#10;```csharp&#10;using EventCoalTrain.EventStructure;&#10;using EventCoalTrain.EventSource;&#10;&#10;// 1) Define the payload as a record/record struct&#10;public readonly record struct ScoreIncreased(int Amount, string Source);&#10;&#10;public static class Events&#10;{&#10;    // 2) Define and cache the event key typed on the payload record&#10;    public static readonly EventKey&lt;ScoreIncreased&gt; ScoreIncreasedKey = EventKey&lt;ScoreIncreased&gt;.Of(&quot;ScoreIncreased&quot;);&#10;&#10;    // 3) Optionally cache a packet descriptor (key only)&#10;    public static readonly Packet&lt;ScoreIncreased&gt; ScoreIncreased = new Packet&lt;ScoreIncreased&gt;(ScoreIncreasedKey);&#10;&#10;    // Notification-style event (no payload). Cache both key and notification instance.&#10;    public static readonly EventKey&lt;Unit&gt; ButtonClickedKey = EventKey&lt;Unit&gt;.Of(&quot;ButtonClicked&quot;);&#10;    public static readonly Notification ButtonClicked = new Notification(ButtonClickedKey);&#10;}&#10;```&#10;&#10;- Subscribe using the cached keys/notifications via EventBus.Instance.&#10;- Publish using either the cached packet descriptor or the key directly with a fresh payload instance each time.&#10;&#10;## Quick start&#10;```csharp&#10;using EventCoalTrain.EventStructure;&#10;using EventCoalTrain.EventSource;&#10;using EventCoalTrain.EventHandling;&#10;&#10;// Subscribe (preferred instance API returning IDisposable)&#10;var subScore = EventBus.Instance.Subscribe(Events.ScoreIncreasedKey, e =&gt; Console.WriteLine($&quot;+{e.Amount} ({e.Source})&quot;));&#10;var subClick = EventBus.Instance.Subscribe(Events.ButtonClicked, () =&gt; Console.WriteLine(&quot;clicked&quot;));&#10;&#10;// Publish with a cached packet descriptor + fresh payload&#10;EventBus.Publish(Events.ScoreIncreased, new ScoreIncreased(10, &quot;LevelComplete&quot;));&#10;&#10;// Or publish with key + payload&#10;EventBus.Publish(Events.ScoreIncreasedKey, new ScoreIncreased(5, &quot;Combo&quot;));&#10;&#10;// Notification publish reuses cached notification&#10;EventBus.Publish(Events.ButtonClicked);&#10;&#10;// Unsubscribe via disposables&#10;subScore.Dispose();&#10;subClick.Dispose();&#10;```&#10;&#10;Notes:&#10;- Cache and reuse EventKey&lt;T&gt; and optional Packet&lt;T&gt; descriptors; supply a new payload per publish. This is allocation-light (especially with record structs) and thread-safe.&#10;- Prefer EventBus.Instance for subscriptions to get IDisposable handles.&#10;- The static wrapper methods exist for convenience/back-compat; the instance API is recommended for lifecycle management.&#10;&#10;## API overview&#10;&#10;### Event keys, packet descriptors, and payload records&#10;```csharp&#10;public readonly record struct DamageTaken(int Amount, string Cause);&#10;&#10;var DamageTakenKey = EventKey&lt;DamageTaken&gt;.Of(&quot;DamageTaken&quot;);&#10;var DamageTakenPacket = new Packet&lt;DamageTaken&gt;(DamageTakenKey); // descriptor&#10;var TickedKey = EventKey&lt;Unit&gt;.Of(&quot;Ticked&quot;);&#10;var Ticked = new Notification(TickedKey);&#10;```&#10;- Equality and GetHashCode of EventKey include both Name and payload type to avoid cross-type collisions.&#10;- Names must still be unique globally (across all payload types).&#10;&#10;### Subscribing (instance, preferred)&#10;```csharp&#10;var sub1 = EventBus.Instance.Subscribe(DamageTakenKey, d =&gt; Console.WriteLine($&quot;damage {d.Amount} from {d.Cause}&quot;));&#10;var sub2 = EventBus.Instance.Subscribe(Ticked, () =&gt; Console.WriteLine(&quot;ticked&quot;));&#10;&#10;// Unsubscribe&#10;sub1.Dispose();&#10;sub2.Dispose();&#10;```&#10;&#10;### Publishing&#10;```csharp&#10;// Using cached descriptor + fresh payload&#10;EventBus.Publish(DamageTakenPacket, new DamageTaken(5, &quot;Trap&quot;));&#10;&#10;// Or using key + payload&#10;EventBus.Publish(DamageTakenKey, new DamageTaken(3, &quot;Fall&quot;));&#10;&#10;EventBus.Publish(Ticked);&#10;```&#10;&#10;### Bulk operations&#10;```csharp&#10;EventBus.UnsubscribeAll(DamageTakenKey);&#10;bool any = EventBus.HasSubscribers(DamageTakenKey);&#10;int count = EventBus.Count(DamageTakenKey);&#10;EventBus.Clear(); // remove all subscriptions&#10;```&#10;&#10;### Error handling&#10;When a subscriber throws during publish, publishing continues for other subscribers. You can observe errors via a callback:&#10;```csharp&#10;EventBus.OnPublishError += (ex, key, del) =&gt;&#10;{&#10;    Console.Error.WriteLine($&quot;Subscriber threw for {key.Name}: {ex}&quot;);&#10;};&#10;```&#10;&#10;## Thread-safety and iteration&#10;- The internal subscribers map is guarded by a lock for all mutations and lookups.&#10;- Publish iterates over a snapshot to avoid issues if handlers subscribe/unsubscribe during delivery.&#10;- After unsubscription, empty handler lists are removed to keep memory usage small.&#10;&#10;## NuGet preprocessor symbol&#10;When you add the EventCoalTrain NuGet package, the compile symbol `EVENTCOALTRAIN` is automatically defined in your consuming project via a `buildTransitive` MSBuild props.&#10;&#10;Example:&#10;```csharp&#10;#if EVENTCOALTRAIN&#10;Console.WriteLine(&quot;EventCoalTrain is referenced.&quot;);&#10;#endif&#10;```&#10;Works for direct and transitive references. No project changes required.&#10;&#10;### Unity without NuGet&#10;If you drop the DLL directly into Unity (not via NuGet), Unity won’t import MSBuild props. Define the symbol manually in Player Settings &gt; Scripting Define Symbols: `EVENTCOALTRAIN`.&#10;&#10;### Opting out&#10;Override `DefineConstants` in your project, or add a props after package imports to remove the symbol if needed.&#10;&#10;### What’s inside the package&#10;The package ships `buildTransitive/EventCoalTrain.props` with:&#10;```xml&#10;&lt;Project&gt;&#10;  &lt;PropertyGroup&gt;&#10;    &lt;DefineConstants&gt;$(DefineConstants);EVENTCOALTRAIN&lt;/DefineConstants&gt;&#10;  &lt;/PropertyGroup&gt;&#10;&lt;/Project&gt;&#10;```&#10;&#10;## License&#10;MIT" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/EventCoalTrain.Tests/EventCoalTrain.Tests.csproj">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/EventCoalTrain.Tests/EventCoalTrain.Tests.csproj" />
              <option name="originalContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;&#10;    &lt;PropertyGroup&gt;&#10;        &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;&#10;        &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;&#10;        &lt;Nullable&gt;enable&lt;/Nullable&gt;&#10;&#10;        &lt;IsPackable&gt;false&lt;/IsPackable&gt;&#10;        &lt;IsTestProject&gt;true&lt;/IsTestProject&gt;&#10;    &lt;/PropertyGroup&gt;&#10;&#10;    &lt;ItemGroup&gt;&#10;        &lt;PackageReference Include=&quot;coverlet.collector&quot; Version=&quot;6.0.0&quot;/&gt;&#10;        &lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.8.0&quot;/&gt;&#10;        &lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.5.3&quot;/&gt;&#10;        &lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;2.5.3&quot;/&gt;&#10;    &lt;/ItemGroup&gt;&#10;&#10;    &lt;ItemGroup&gt;&#10;        &lt;Using Include=&quot;Xunit&quot;/&gt;&#10;    &lt;/ItemGroup&gt;&#10;&#10;&lt;/Project&gt;&#10;" />
              <option name="updatedContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#13;&#10;&#13;&#10;    &lt;PropertyGroup&gt;&#13;&#10;        &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;&#13;&#10;        &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;&#13;&#10;        &lt;Nullable&gt;enable&lt;/Nullable&gt;&#13;&#10;&#13;&#10;        &lt;IsPackable&gt;false&lt;/IsPackable&gt;&#13;&#10;        &lt;IsTestProject&gt;true&lt;/IsTestProject&gt;&#13;&#10;    &lt;/PropertyGroup&gt;&#13;&#10;&#13;&#10;    &lt;ItemGroup&gt;&#13;&#10;        &lt;PackageReference Include=&quot;coverlet.collector&quot; Version=&quot;6.0.0&quot;/&gt;&#13;&#10;        &lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.8.0&quot;/&gt;&#13;&#10;        &lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.5.3&quot;/&gt;&#13;&#10;        &lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;2.5.3&quot;/&gt;&#13;&#10;    &lt;/ItemGroup&gt;&#13;&#10;&#13;&#10;    &lt;ItemGroup&gt;&#13;&#10;        &lt;Using Include=&quot;Xunit&quot;/&gt;&#13;&#10;    &lt;/ItemGroup&gt;&#13;&#10;&#13;&#10;    &lt;ItemGroup&gt;&#13;&#10;        &lt;ProjectReference Include=&quot;..\EventCoalTrain.csproj&quot; /&gt;&#13;&#10;    &lt;/ItemGroup&gt;&#13;&#10;&#13;&#10;&lt;/Project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/EventCoalTrain.csproj">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/EventCoalTrain.csproj" />
              <option name="originalContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;&#10;    &lt;PropertyGroup&gt;&#10;        &lt;TargetFrameworks&gt;net8.0;netstandard2.1&lt;/TargetFrameworks&gt;&#10;        &lt;LangVersion&gt;latestMajor&lt;/LangVersion&gt;&#10;        &lt;GenerateDocumentationFile&gt;true&lt;/GenerateDocumentationFile&gt;&#10;        &lt;PackageId&gt;EventCoalTrain&lt;/PackageId&gt;&#10;        &lt;Version&gt;1.0.0&lt;/Version&gt;&#10;        &lt;Authors&gt;Christos Maragkos&lt;/Authors&gt;&#10;        &lt;Description&gt;Event system for Godot (.NET 9.0) and Unity (.NET Standard 2.1).&lt;/Description&gt;&#10;        &lt;RepositoryUrl&gt;https://github.com/ChristosMaragkos/EventCoalTrain&lt;/RepositoryUrl&gt;&#10;        &lt;PackageLicenseExpression&gt;MIT&lt;/PackageLicenseExpression&gt;&#10;        &lt;PackageProjectUrl&gt;https://github.com/ChristosMaragkos/EventCoalTrain&lt;/PackageProjectUrl&gt;&#10;        &lt;Copyright&gt;Copyright © 2025 Christos Maragkos&lt;/Copyright&gt;&#10;        &lt;IncludeSymbols&gt;true&lt;/IncludeSymbols&gt;&#10;        &lt;SymbolPackageFormat&gt;snupkg&lt;/SymbolPackageFormat&gt;&#10;        &lt;PackageReadmeFile&gt;README.md&lt;/PackageReadmeFile&gt;&#10;    &lt;/PropertyGroup&gt;&#10;&#10;    &lt;ItemGroup&gt;&#10;        &lt;!-- Ensure buildTransitive props are packed so consumers get the EVENTCOALTRAIN symbol --&gt;&#10;        &lt;None Include=&quot;buildTransitive\**\*.*&quot; Pack=&quot;true&quot; PackagePath=&quot;buildTransitive\&quot; /&gt;&#10;        &lt;!-- Include README in the package root --&gt;&#10;        &lt;None Include=&quot;README.md&quot; Pack=&quot;true&quot; PackagePath=&quot;/&quot; /&gt;&#10;    &lt;/ItemGroup&gt;&#10;&#10;&lt;/Project&gt;&#10;" />
              <option name="updatedContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;&#10;    &lt;PropertyGroup&gt;&#10;        &lt;TargetFrameworks&gt;net8.0;netstandard2.1&lt;/TargetFrameworks&gt;&#10;        &lt;LangVersion&gt;latestMajor&lt;/LangVersion&gt;&#10;        &lt;GenerateDocumentationFile&gt;true&lt;/GenerateDocumentationFile&gt;&#10;        &lt;PackageId&gt;EventCoalTrain&lt;/PackageId&gt;&#10;        &lt;Version&gt;1.0.0&lt;/Version&gt;&#10;        &lt;Authors&gt;Christos Maragkos&lt;/Authors&gt;&#10;        &lt;Description&gt;Event system for Godot (.NET 9.0) and Unity (.NET Standard 2.1).&lt;/Description&gt;&#10;        &lt;RepositoryUrl&gt;https://github.com/ChristosMaragkos/EventCoalTrain&lt;/RepositoryUrl&gt;&#10;        &lt;PackageLicenseExpression&gt;MIT&lt;/PackageLicenseExpression&gt;&#10;        &lt;PackageProjectUrl&gt;https://github.com/ChristosMaragkos/EventCoalTrain&lt;/PackageProjectUrl&gt;&#10;        &lt;Copyright&gt;Copyright © 2025 Christos Maragkos&lt;/Copyright&gt;&#10;        &lt;IncludeSymbols&gt;true&lt;/IncludeSymbols&gt;&#10;        &lt;SymbolPackageFormat&gt;snupkg&lt;/SymbolPackageFormat&gt;&#10;        &lt;PackageReadmeFile&gt;README.md&lt;/PackageReadmeFile&gt;&#10;    &lt;/PropertyGroup&gt;&#10;&#10;    &lt;ItemGroup&gt;&#10;        &lt;!-- Ensure buildTransitive props are packed so consumers get the EVENTCOALTRAIN symbol --&gt;&#10;        &lt;None Include=&quot;buildTransitive\**\*.*&quot; Pack=&quot;true&quot; PackagePath=&quot;buildTransitive\&quot; /&gt;&#10;        &lt;!-- Include README in the package root --&gt;&#10;        &lt;None Include=&quot;README.md&quot; Pack=&quot;true&quot; PackagePath=&quot;/&quot; /&gt;&#10;    &lt;/ItemGroup&gt;&#10;&#10;&lt;/Project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/EventHandling/EventBus.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/EventHandling/EventBus.cs" />
              <option name="originalContent" value="#nullable enable&#10;using System;&#10;using System.Collections.Generic;&#10;using EventCoalTrain.EventSource;&#10;using EventCoalTrain.EventStructure;&#10;&#10;namespace EventCoalTrain.EventHandling;&#10;/// &lt;summary&gt;&#10;/// Static wrapper over a thread-safe event bus implementation.&#10;/// &lt;/summary&gt;&#10;public static class EventBus&#10;{&#10;    private static IEventBus _bus = new DefaultEventBus();&#10;&#10;    /// &lt;summary&gt;&#10;    /// Contains all registered event key names (used by EventKey.Of for uniqueness).&#10;    /// &lt;/summary&gt;&#10;    public static readonly HashSet&lt;string&gt; RegisteredKeys = new();&#10;&#10;    /// &lt;summary&gt;&#10;    /// Access the underlying event bus instance (supports IDisposable subscriptions).&#10;    /// &lt;/summary&gt;&#10;    public static IEventBus Instance =&gt; _bus;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Replace the underlying bus implementation.&#10;    /// &lt;/summary&gt;&#10;    public static void Configure(IEventBus bus)&#10;        =&gt; _bus = bus ?? throw new ArgumentNullException(nameof(bus));&#10;&#10;    /// &lt;summary&gt;&#10;    /// Raised when a subscriber throws during publish.&#10;    /// &lt;/summary&gt;&#10;    public static event Action&lt;Exception, IEventKey, Delegate&gt;? OnPublishError&#10;    {&#10;        add { _bus.OnPublishError += value; }&#10;        remove { _bus.OnPublishError -= value; }&#10;    }&#10;&#10;    // Subscribe (legacy shape using Packet/Notification)&#10;    public static void Subscribe&lt;TPayload&gt;(Packet&lt;TPayload&gt; packet, Action&lt;TPayload&gt; handler)&#10;        =&gt; _bus.Subscribe(packet.Key, handler);&#10;&#10;    public static void Subscribe(Notification notification, Action handler)&#10;        =&gt; _bus.Subscribe(notification, handler);&#10;&#10;    // Unsubscribe (legacy shape)&#10;    public static void Unsubscribe&lt;TPayload&gt;(Packet&lt;TPayload&gt; packet, Action&lt;TPayload&gt; handler)&#10;        =&gt; _bus.Unsubscribe(packet.Key, handler);&#10;&#10;    public static void Unsubscribe(Notification notification, Action handler)&#10;        =&gt; _bus.Unsubscribe(notification, handler);&#10;&#10;    // Publish&#10;    public static void Publish&lt;TPayload&gt;(Packet&lt;TPayload&gt; packet) =&gt; _bus.Publish(packet);&#10;    public static void Publish(Notification notification) =&gt; _bus.Publish(notification);&#10;&#10;    // Bulk operations&#10;    public static void UnsubscribeAll(IEventKey key) =&gt; _bus.UnsubscribeAll(key);&#10;    public static bool HasSubscribers(IEventKey key) =&gt; _bus.HasSubscribers(key);&#10;    public static int Count(IEventKey key) =&gt; _bus.Count(key);&#10;    public static void Clear() =&gt; _bus.Clear();&#10;}" />
              <option name="updatedContent" value="#nullable enable&#10;using System;&#10;using System.Collections.Generic;&#10;using EventCoalTrain.EventSource;&#10;using EventCoalTrain.EventStructure;&#10;&#10;namespace EventCoalTrain.EventHandling;&#10;/// &lt;summary&gt;&#10;/// Static wrapper over a thread-safe event bus implementation.&#10;/// &lt;/summary&gt;&#10;public static class EventBus&#10;{&#10;    private static IEventBus _bus = new DefaultEventBus();&#10;&#10;    /// &lt;summary&gt;&#10;    /// Contains all registered event key names (used by EventKey.Of for uniqueness).&#10;    /// &lt;/summary&gt;&#10;    public static readonly HashSet&lt;string&gt; RegisteredKeys = new();&#10;&#10;    /// &lt;summary&gt;&#10;    /// Access the underlying event bus instance (supports IDisposable subscriptions).&#10;    /// &lt;/summary&gt;&#10;    public static IEventBus Instance =&gt; _bus;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Replace the underlying bus implementation.&#10;    /// &lt;/summary&gt;&#10;    public static void Configure(IEventBus bus)&#10;        =&gt; _bus = bus ?? throw new ArgumentNullException(nameof(bus));&#10;&#10;    /// &lt;summary&gt;&#10;    /// Raised when a subscriber throws during publish.&#10;    /// &lt;/summary&gt;&#10;    public static event Action&lt;Exception, IEventKey, Delegate&gt;? OnPublishError&#10;    {&#10;        add { _bus.OnPublishError += value; }&#10;        remove { _bus.OnPublishError -= value; }&#10;    }&#10;&#10;    // Subscribe (legacy shape using Packet/Notification)&#10;    public static void Subscribe&lt;TPayload&gt;(Packet&lt;TPayload&gt; packet, Action&lt;TPayload&gt; handler)&#10;        =&gt; _bus.Subscribe(packet.Key, handler);&#10;&#10;    public static void Subscribe(Notification notification, Action handler)&#10;        =&gt; _bus.Subscribe(notification, handler);&#10;&#10;    // Unsubscribe (legacy shape)&#10;    public static void Unsubscribe&lt;TPayload&gt;(Packet&lt;TPayload&gt; packet, Action&lt;TPayload&gt; handler)&#10;        =&gt; _bus.Unsubscribe(packet.Key, handler);&#10;&#10;    public static void Unsubscribe(Notification notification, Action handler)&#10;        =&gt; _bus.Unsubscribe(notification, handler);&#10;&#10;    // Publish&#10;    public static void Publish&lt;TPayload&gt;(Packet&lt;TPayload&gt; packet) =&gt; _bus.Publish(packet);&#10;    public static void Publish(Notification notification) =&gt; _bus.Publish(notification);&#10;&#10;    // Bulk operations&#10;    public static void UnsubscribeAll(IEventKey key) =&gt; _bus.UnsubscribeAll(key);&#10;    public static bool HasSubscribers(IEventKey key) =&gt; _bus.HasSubscribers(key);&#10;    public static int Count(IEventKey key) =&gt; _bus.Count(key);&#10;    public static void Clear() =&gt; _bus.Clear();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/EventStructure/EventKey.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/EventStructure/EventKey.cs" />
              <option name="originalContent" value="using System;&#10;using EventCoalTrain.EventHandling;&#10;&#10;namespace EventCoalTrain.EventStructure;&#10;&#10;/// &lt;summary&gt;&#10;/// Represents a strongly-typed event key for use with the event bus.&#10;/// Ensures unique registration of event keys by name.&#10;/// Event keys associated with a packet must carry a payload with a specific type,&#10;/// while event keys associated with a notification do not require a payload and can thus&#10;/// be registered with a payload type of &lt;see cref=&quot;Unit&quot;/&gt;.&#10;/// &lt;/summary&gt;&#10;/// &lt;typeparam name=&quot;TPayload&quot;&gt;The type of the event payload.&lt;/typeparam&gt;&#10;public sealed class EventKey&lt;TPayload&gt; : IEventKey&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Gets the name of the event key.&#10;    /// &lt;/summary&gt;&#10;    public string Name { get; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Initializes a new instance of the &lt;see cref=&quot;EventKey{TPayload}&quot;/&gt; class.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;name&quot;&gt;The name of the event key.&lt;/param&gt;&#10;    private EventKey(string name)&#10;    {&#10;        Name = name;&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Factory method that creates and registers a new event key with the specified name.&#10;    /// Throws if the name is null, whitespace, or already registered.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;name&quot;&gt;The name of the event key.&lt;/param&gt;&#10;    /// &lt;returns&gt;A new &lt;see cref=&quot;EventKey{TPayload}&quot;/&gt; instance.&lt;/returns&gt;&#10;    /// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown if name is null or whitespace.&lt;/exception&gt;&#10;    /// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;Thrown if the name is already registered.&lt;/exception&gt;&#10;    public static EventKey&lt;TPayload&gt; Of(string name)&#10;    {&#10;        if (string.IsNullOrWhiteSpace(name))&#10;            throw new ArgumentException(&quot;Event key name cannot be null or whitespace.&quot;, nameof(name));&#10;&#10;        lock (EventBus.RegisteredKeys)&#10;        {&#10;            if (!EventBus.RegisteredKeys.Add(name))&#10;                throw new InvalidOperationException($&quot;Event key '{name}' is already registered.&quot;);&#10;        }&#10;&#10;        return new EventKey&lt;TPayload&gt;(name);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Returns a string representation of the event key.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;A string describing the event key.&lt;/returns&gt;&#10;    public override string ToString() =&gt; $&quot;EventKey&lt;{typeof(TPayload).Name}&gt;: {Name}&quot;;&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified object is equal to the current event key.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;obj&quot;&gt;The object to compare with the current event key.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the specified object is equal to the current event key; otherwise, false.&lt;/returns&gt;&#10;    public override bool Equals(object obj)&#10;        =&gt; obj is EventKey&lt;TPayload&gt; other &amp;&amp; other.Name == Name;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Returns a hash code for the event key.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;A hash code for the event key.&lt;/returns&gt;&#10;    public override int GetHashCode()&#10;    {&#10;        unchecked&#10;        {&#10;            int hash = 17;&#10;            hash = hash * 31 + Name.GetHashCode();&#10;            hash = hash * 31 + typeof(TPayload).GetHashCode();&#10;            return hash;&#10;        }&#10;    }&#10;    &#10;#if DEBUG&#10;    /// &lt;summary&gt;&#10;    /// Clears the event key registry for testing purposes. Only available in DEBUG builds.&#10;    /// &lt;/summary&gt;&#10;    public static void ClearRegistryForTesting()&#10;    {&#10;        lock (EventBus.RegisteredKeys)&#10;        {&#10;            EventBus.RegisteredKeys.Clear();&#10;        }&#10;    }&#10;#endif&#10;}" />
              <option name="updatedContent" value="using System;&#10;using EventCoalTrain.EventHandling;&#10;&#10;namespace EventCoalTrain.EventStructure;&#10;&#10;/// &lt;summary&gt;&#10;/// Represents a strongly-typed event key for use with the event bus.&#10;/// Ensures unique registration of event keys by name.&#10;/// Event keys associated with a packet must carry a payload with a specific type,&#10;/// while event keys associated with a notification do not require a payload and can thus&#10;/// be registered with a payload type of &lt;see cref=&quot;Unit&quot;/&gt;.&#10;/// &lt;/summary&gt;&#10;/// &lt;typeparam name=&quot;TPayload&quot;&gt;The type of the event payload.&lt;/typeparam&gt;&#10;public sealed class EventKey&lt;TPayload&gt; : IEventKey&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Gets the name of the event key.&#10;    /// &lt;/summary&gt;&#10;    public string Name { get; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Initializes a new instance of the &lt;see cref=&quot;EventKey{TPayload}&quot;/&gt; class.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;name&quot;&gt;The name of the event key.&lt;/param&gt;&#10;    private EventKey(string name)&#10;    {&#10;        Name = name;&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Factory method that creates and registers a new event key with the specified name.&#10;    /// Throws if the name is null, whitespace, or already registered.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;name&quot;&gt;The name of the event key.&lt;/param&gt;&#10;    /// &lt;returns&gt;A new &lt;see cref=&quot;EventKey{TPayload}&quot;/&gt; instance.&lt;/returns&gt;&#10;    /// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown if name is null or whitespace.&lt;/exception&gt;&#10;    /// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;Thrown if the name is already registered.&lt;/exception&gt;&#10;    public static EventKey&lt;TPayload&gt; Of(string name)&#10;    {&#10;        if (string.IsNullOrWhiteSpace(name))&#10;            throw new ArgumentException(&quot;Event key name cannot be null or whitespace.&quot;, nameof(name));&#10;&#10;        lock (EventBus.RegisteredKeys)&#10;        {&#10;            if (!EventBus.RegisteredKeys.Add(name))&#10;                throw new InvalidOperationException($&quot;Event key '{name}' is already registered.&quot;);&#10;        }&#10;&#10;        return new EventKey&lt;TPayload&gt;(name);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Returns a string representation of the event key.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;A string describing the event key.&lt;/returns&gt;&#10;    public override string ToString() =&gt; $&quot;EventKey&lt;{typeof(TPayload).Name}&gt;: {Name}&quot;;&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified object is equal to the current event key.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;obj&quot;&gt;The object to compare with the current event key.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the specified object is equal to the current event key; otherwise, false.&lt;/returns&gt;&#10;    public override bool Equals(object obj)&#10;        =&gt; obj is EventKey&lt;TPayload&gt; other &amp;&amp; other.Name == Name;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Returns a hash code for the event key.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;A hash code for the event key.&lt;/returns&gt;&#10;    public override int GetHashCode()&#10;    {&#10;        unchecked&#10;        {&#10;            int hash = 17;&#10;            hash = hash * 31 + Name.GetHashCode();&#10;            hash = hash * 31 + typeof(TPayload).GetHashCode();&#10;            return hash;&#10;        }&#10;    }&#10;    &#10;#if DEBUG&#10;    /// &lt;summary&gt;&#10;    /// Clears the event key registry for testing purposes. Only available in DEBUG builds.&#10;    /// &lt;/summary&gt;&#10;    public static void ClearRegistryForTesting()&#10;    {&#10;        lock (EventBus.RegisteredKeys)&#10;        {&#10;            EventBus.RegisteredKeys.Clear();&#10;        }&#10;    }&#10;#endif&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>